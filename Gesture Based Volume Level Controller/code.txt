/*!
 * \name        Smart Switch Demo
 * \author      Muhammad Hamza Jawaid
 * \brief       
 * \details 
 * @date 22-07-2021   
 *
 *            
 */

#include <Arduino.h>

#include <Servo.h>
/* Include library main header */
#include <bgt60-ino.hpp>
/* Include Arduino platform header */
#include <bgt60-platf-ino.hpp>

#include <WiFiNINA.h>//wifi library for mkrwifi 1010


#include <utility/wifi_drv.h>//library for onboard LED control


/*
* In case no supported platform is defined, the
* PD and TD pin are set to the values below.
*/
#ifndef TD
#define TD  15
#endif

#ifndef PD
#define PD  16
#endif

#define approach Bgt60::APPROACHING
#define depart Bgt60::DEPARTING
#define nodir Bgt60::NO_DIR
Servo myservo;

int GreenLED=25;//Pin number for onboard Green LED
int RedLED=26;//Pin number for onboard Red LED
int BlueLED=27;//Pin number for onboard Blue LED

int Led=14;

unsigned long myTime1;
unsigned long myTime2;
unsigned long t1;
unsigned long t2;

const long interval = 1800; 
const long interval_2 = 400; 


int gstrstate=1;
int servopos=90;





/* Functions */
bool DirChanged(Bgt60::Direction_t *dir);
bool Gesture(Bgt60::Direction_t *dir2);







/* Create radar object with following arguments:
 *  TD : Target Detect Pin
 *  PD : Phase Detect Pin */
Bgt60Ino radarShield(TD, PD);

/* Begin setup function - takes care of initialization and executes only once post reset */
void setup()
{
    /* Set the baud rate for sending messages to the serial monitor */
    Serial.begin(9600);

    
    WiFiDrv::pinMode(RedLED, OUTPUT); //syntax defining MKR wifi1010 onboard LED as OUTPUT.
    WiFiDrv::pinMode(BlueLED, OUTPUT); 
    WiFiDrv::pinMode(GreenLED, OUTPUT);
    pinMode(Led,OUTPUT);
    myservo.attach(9); 
    
    // Configures the GPIO pins to input mode
    Error_t init_status = radarShield.init();
    /* Check if the initialization was successful */
    if (OK != init_status) {
        Serial.println("Init failed.");
    }
    else {
        Serial.println("Init successful.");
    }


}


Error_t err;



/* Begin loop function - this part of code is executed continuously until external termination */
void loop()
{

  

  /* Create variables to store the state of the motion as well as the direction */
  Bgt60::Motion_t motion = Bgt60::NO_MOTION;
  
  /* Initialize the variable to NO_DIR to be able to record new events */
 err = radarShield.getMotion(motion);

 if(err == OK)
    {
    if (motion==Bgt60::MOTION)
    {
      Serial.println("Motion");
      WiFiDrv::digitalWrite(RedLED, HIGH);
      WiFiDrv::digitalWrite(BlueLED, LOW);
      WiFiDrv::digitalWrite(GreenLED, LOW);

                start:
              
                Bgt60::Direction_t direction = nodir;

                err = radarShield.getDirection(direction);

                if(OK == err)
                { 
                switch (direction)
                {
                case Bgt60::APPROACHING:
                myTime1 = millis();
                Serial.println(myTime1);
                Serial.println("0");

                    while(direction==Bgt60::APPROACHING)
                    {
                        err = radarShield.getDirection(direction);
                        if(OK == err)
                        {
                          if (direction!=Bgt60::APPROACHING)
                          {
                            break;
                          }
                        }
                    }

                    t2=millis();

                    if(t2-myTime1>interval_2)
                    {
                      goto start;
                    }


                                       
      
      //case 2:
        t1=millis();
        Serial.println("2");
        direction=depart;
        
         err = radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::DEPARTING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::DEPARTING) 
               { 
                break;
                }
             }

           }
         }

        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        

      //break;




      //case 4:
         t1=millis();
         Serial.println("4");
         direction = approach;
         err= radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::APPROACHING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::APPROACHING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        


      //break;



        //case 6:
         t1=millis();
         Serial.println("6");
         direction = depart;
         err = radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::DEPARTING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::DEPARTING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
                

      //break;



      //case 8:
         t1=millis();
         Serial.println("8");
         direction = approach;
         err= radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::APPROACHING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::APPROACHING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        
      
      //break;



                                      
                break;


                case Bgt60::DEPARTING:
                myTime1 = millis();
                Serial.println(myTime1);
                Serial.println("00");
                    
                    while(direction==Bgt60::DEPARTING)
                    {
                        err = radarShield.getDirection(direction);
                        if(OK == err)
                        {
                          if (direction!=Bgt60::DEPARTING)
                          {
                            break;
                          }
                        }
                    }

                    t2=millis();

                    if(t2-myTime1>interval_2)
                    {
                      goto start;
                    }                  
   




      //case 3:
         t1=millis();
         Serial.println("3");
         direction=approach;

         err = radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::APPROACHING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::APPROACHING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        
      
      //break;




      //case 5:
         t1=millis();
         Serial.println("5");
         direction = depart;
         err = radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::DEPARTING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::DEPARTING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        
      
      //break;






      //case 7:
         t1=millis();
         Serial.println("7");
         direction = approach;
         err= radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::APPROACHING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::APPROACHING) 
               { 
                break;
                }
             }

           }
         }  
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        

      //break;





      //case 9:
         t1=millis();
         Serial.println("9");
         direction = depart;
         err = radarShield.getDirection(direction);
         if(OK == err)
         {
           while(direction==Bgt60::DEPARTING)
           {
             err = radarShield.getDirection(direction);
             if(OK == err)
             {
               if (direction!=Bgt60::DEPARTING) 
               { 
                break;
                }
             }

           }
         }
        t2=millis();

        if(t2-t1>interval_2)
        {
          goto start;
        }
        
     
      //break;








                  break;

                  case Bgt60::NO_DIR:
                  Serial.println("no direction");
                  myTime1 = 0;
                  //goto last;
                  break;
                  
              
                  }
              }







  myTime2=millis();
  Serial.println(myTime2);
  Serial.println(myTime2-myTime1);




  if(myTime2-myTime1<interval){

    //Serial.println(myTime2-myTime1);
    WiFiDrv::digitalWrite(RedLED, LOW);
    WiFiDrv::digitalWrite(BlueLED, HIGH);
    delay(500);
    WiFiDrv::digitalWrite(RedLED, LOW);
    WiFiDrv::digitalWrite(BlueLED, LOW);
    WiFiDrv::digitalWrite(GreenLED, HIGH);

    if(servopos==90)
    {

    myservo.write(0);
    servopos=0;
    digitalWrite(Led,HIGH);


    }

    else{

    myservo.write(90);
    servopos=90;
    digitalWrite(Led,LOW);

    }



    err = radarShield.getMotion(motion);
    if(err == OK)
    {
      while(motion==Bgt60::MOTION){
          err = radarShield.getMotion(motion);
          if(err == OK){
            if (motion!=Bgt60::MOTION) 
               { 
                break;
                }
          }
      }

    }   

    WiFiDrv::digitalWrite(RedLED, LOW);
    WiFiDrv::digitalWrite(BlueLED, LOW);
    WiFiDrv::digitalWrite(GreenLED, LOW);   


  
  } //if(myTime2-myTime1<interval) end






//last:

    
} //if (motion==Bgt60::MOTION) end


   
else{
    WiFiDrv::digitalWrite(RedLED, LOW);
    WiFiDrv::digitalWrite(BlueLED, LOW);
    WiFiDrv::digitalWrite(GreenLED, LOW);
    Serial.println("No Motion");
  }


  

} //if err end



else{

     WiFiDrv::digitalWrite(RedLED, LOW);
     WiFiDrv::digitalWrite(BlueLED, LOW);
     WiFiDrv::digitalWrite(GreenLED, LOW);
     Serial.println("eRROR Occured");
     
  }
  
  
  
  //end:
  
} //loop end



                 /* if (Gesture(&direction)==true)
                  {
                    WiFiDrv::digitalWrite(RedLED, LOW);
                    WiFiDrv::digitalWrite(BlueLED, HIGH);
                    Serial.println("Yes");
                  }*/


    
    




bool DirChanged(Bgt60::Direction_t *dir)
{

  bool accept = false;
  Bgt60::Direction_t dir2 = *dir;

    Error_t err = radarShield.getDirection(*dir);      

    if (err == OK)
    {

      if(dir2 != *dir)
      {
        accept = true;

      }
      else{
        accept = false;
      }
    }
    else{
        Serial.println("Error occurred!");
    }

return accept;
  
}


















bool Gesture(Bgt60::Direction_t *dir2)
{



  bool flag2 = false;

  int gstrstate = 1;

  switch (gstrstate)
  {
   
  case 1:

      while (DirChanged(dir2))
      {
      }
      //*dir2 = curr->currdir;
      gstrstate = 2;
     
    break;


  case 2:

      while (DirChanged(dir2))
      {
      }
      //*dir2 = curr->currdir;
      gstrstate = 1;
      flag2 = true;

    break;

  }

  return flag2;
}


